"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.customParseRules = exports.keywords = exports.name = undefined;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

var _dotnet = require("./common/dotnet.js");

var DotNetCommon = _interopRequireWildcard(_dotnet);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* eslint no-magic-numbers: 1 */
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var primitives = ["int", "bool", "double", "float", "char", "byte", "sbyte", "uint", "long", "ulong", "char", "decimal", "short", "ushort"];
// things that are allowed inside a generic type definition
var acceptableKeywords = primitives.concat(["in", "out", "string", "object"]);

var typeDefinitionRegex = /^T([A-Z0-9]\w*)?$/;
/**
 * TODO: description
 * @param {function} func
 * @return {function}
 */
function createNamedIdentFunction(func) {
  return function (context) {
    return !typeDefinitionRegex.test(context.tokens[context.index].value) && func(context);
  };
}

var name = exports.name = "csharp";

var keywords = exports.keywords = primitives.concat([
// this is also contextual (must be first thing in the file or something), but
// it's never used so i don't really care
"extern alias",

// class qualifiers
"public", "private", "protected", "internal", "static", "sealed", "abstract", "partial",

// method qualifiers
"virtual", "override", "new", "implicit", "explicit", "extern", "override", "operator",

// member qualifiers
"const", "readonly", "volatile",

// types
"class", "interface", "enum", "struct", "event", "delegate",

// literals
"null", "true", "false",

// aliases
"string", "object", "void",

// looping
"for", "foreach", "do", "while",

// scoping
"fixed", "unchecked", "using", "lock", "namespace", "checked", "unsafe",

// flow control
"if", "else", "try", "catch", "finally", "break", "continue", "goto", "case", "throw", "return", "switch", "yield return", "yield break",

// parameter qualifiers
"in", "out", "ref", "params",

// type comparison
"as", "is", "typeof",

// other
"this", "sizeof", "stackalloc", "var", "default",

// contextual keywords
// property stuff
// get, set and value are handled by customParseRules below

// linq
"from", "select", "where", "groupby", "orderby"]);

var customParseRules = exports.customParseRules = [DotNetCommon.XMLDocComment("///"),

// get/set contextual keyword
function (context) {
  var initialLength = "get".length;
  if (!/^(get|set)\b/.test(context.reader.peek(initialLength + 1))) return null;

  if (!util.IsFollowsRuleSatisfied(context.getTokenWalker(), [{ token: "punctuation", values: ["}", "{", ";"] }, util.whitespace, {
    token: "keyword",
    values: ["public", "private", "protected", "internal"],
    optional: true
  }])) return null;

  // now we need to look ahead and verify that the next non-whitespace token is "{" or ";"
  for (var offset = initialLength;; offset++) {
    var peek = context.reader.peekWithOffset(offset);
    if (peek === "") return null;

    if (!/\s$/.test(peek)) {
      if (peek === "{" || peek === ";") break;
      return null;
    }
  }

  var value = context.reader.read(initialLength);
  return context.createToken("keyword", value);
},

// value contextual keyword
function (context) {
  var initialLength = "value".length;
  if (!/^value\b/.test(context.reader.peek(initialLength + 1))) return null;

  // comes after "set" but not after the closing "}" (we'll have to count them to make sure scoping is correct)
  // can't be on the left side of an assignment

  // first check equals because that's easy
  for (var offset = initialLength;; offset++) {
    var peek = context.reader.peekWithOffset(offset);
    if (peek === "") return null;

    if (!/\s$/.test(peek)) {
      if (peek !== "=" || context.reader.peekWithOffset(offset + 1) === "=") break;
      return null;
    }
  }

  // now go backward until we run into a "set" keyword, keeping track of all brackets along the way
  var bracketCount = [0, 0]; // open, close
  var walker = context.getTokenWalker();
  tokenLoop: for (;;) {
    if (!walker.hasPrev()) return null;
    var token = walker.prev();
    if (token.name === "punctuation") {
      if (token.value === "{") bracketCount[0]++;else if (token.value === "}") bracketCount[1]++;
    } else if (token.name === "keyword") {
      switch (token.value) {
        case "set":
          // yay!
          break tokenLoop;
        case "class":
        case "public":
        case "private":
        case "protected":
        case "internal":
          // easiest way to detect we're out of scope so we can stop looking
          return null;
      }
    }
  }

  // examine the bracket count and make sure we're in the correct scope
  if (bracketCount[1] >= bracketCount[0])
    // nope
    return null;

  return context.createToken("keyword", context.reader.read(initialLength));
}];

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false], ['@"', '"', ['""'], false]],
  char: [["'", "'", ["\\'", "\\\\"], false]],
  comment: [["//", "\n", [], true], ["/*", "*/", [], false]],
  pragma: [["#", "\n", [], true]]
};

// TODO: accept all .NET identifier characters, not just ASCII
var identFirstLetter = exports.identFirstLetter = /[A-Za-z_@]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/;

var namedIdentRules = exports.namedIdentRules = {
  custom: [
  // extends/implements/type constraints
  createNamedIdentFunction(function (context) {
    // between ":" and "{" but not case statements

    // look backward for a ":" not preceded by a "case"
    var walker = context.getTokenWalker();
    var foundColon = false;
    while (walker.hasPrev()) {
      var token = walker.prev();
      if (token.name === "punctuation" && token.value === "{") return false;

      if (token.name === "keyword" && token.value === "case") return false;

      if (token.name === "keyword" && (token.value === "class" || token.value === "where")) {
        // the "class" keyword for classes
        // or the "where" keyword for generic methods/classes with type constraints

        // if "class" is used as a type constraint, then ignore it
        var nextToken = walker.peek(1).name === "default" ? walker.peekUnsafe(2) : walker.peek(1);
        if (nextToken && nextToken.name === "punctuation" && nextToken.value === ",") continue;

        break;
      }

      if (token.name === "operator" && token.value === ":")
        // make sure there isn't a case preceding it
        foundColon = true;
    }

    if (!foundColon) return false;

    return true;
  }),

  // generic definitions/params between "<" and ">"
  createNamedIdentFunction(function (context) {
    // between < and > and preceded by an ident and not preceded by "class"

    // look for "<" preceded by an ident but not "class"
    // if we run into ">" before "," or "<" then it's a big fail
    var foundIdent = false;
    var bracketCountLeft = [0, 0];
    var walker = context.getTokenWalker();
    while (walker.hasPrev()) {
      var token = walker.prev();
      if (token.name === "keyword" && token.value === "class")
        // this must be a generic class type definition, e.g. Foo<T>, and we don't want to color the "T"
        return false;

      if (token.name === "operator") {
        switch (token.value) {
          case "<":
          case "<<":
            bracketCountLeft[0] += token.value.length;
            continue;
          case ">":
          case ">>":
            if (bracketCountLeft[0] === 0) return false;

            bracketCountLeft[1] += token.value.length;
            continue;
        }

        break;
      }

      if (token.name === "keyword" && util.contains(acceptableKeywords, token.value) || token.name === "default" || token.name === "punctuation" && token.value === ",") continue;

      if (token.name === "ident") {
        foundIdent = true;
        continue;
      }

      // anything else means we're no longer in a generic definition
      break;
    }

    if (!foundIdent || bracketCountLeft[0] === 0)
      // not inside a generic definition
      return false;

    // now look forward to make sure the generic definition is closed
    // this avoids false positives like "foo < bar"
    walker = context.getTokenWalker();
    while (walker.hasNext()) {
      var _token = walker.next();
      if (_token.name === "operator" && (_token.value === ">" || _token.value === ">>")) return true;

      if (_token.name === "keyword" && util.contains(acceptableKeywords, _token.value) || _token.name === "operator" && util.contains(["<", "<<", ">", ">>"], _token.value) || _token.name === "punctuation" && _token.value === "," || _token.name === "ident" || _token.name === "default") continue;

      return false;
    }

    return false;
  }),

  // generic declarations and return values (ident preceding a generic definition)
  // this finds "Foo" in "Foo<Bar> foo"
  createNamedIdentFunction(function (context) {
    // if it's preceded by an ident or a primitive/alias keyword then it's no good (i.e. a generic method definition like "public void Foo<T>")
    // also a big fail if it is preceded by a ., i.e. a generic method invocation like container.Resolve()
    {
      var _token2 = util.getPreviousNonWsToken(context.tokens, context.index);
      if (_token2) if (_token2.name === "ident" || _token2.name === "keyword" && util.contains(primitives.concat(["string", "object", "void"]), _token2.value) || _token2.name === "operator" && _token2.value === ".") {
        return false;
      }
    }

    // needs to be immediately followed by <, then by idents, acceptable keywords and ",", and then closed by >, then immediately followed by an ident
    {
      var _token3 = util.getNextNonWsToken(context.tokens, context.index);
      if (!_token3 || _token3.name !== "operator" || _token3.value !== "<") return false;
    }

    var bracketCount = [0, 0]; // open (<), close (>)
    var walker = context.getTokenWalker();
    while (walker.hasNext()) {
      var _token4 = walker.next();
      if (_token4.name === "operator") {
        switch (_token4.value) {
          case "<":
            bracketCount[0]++;
            break;
          case "<<":
            bracketCount[0] += 2;
            break;
          case ">":
            bracketCount[1]++;
            break;
          case ">>":
            bracketCount[1] += 2;
            break;
          default:
            return false;
        }

        // if bracket counts match, get the f out
        if (bracketCount[0] === bracketCount[1]) break;

        continue;
      }

      if (_token4.name === "default" || _token4.name === "ident" || _token4.name === "keyword" && util.contains(acceptableKeywords, _token4.value) || _token4.name === "punctuation" && _token4.value === ",") continue;

      return false;
    }

    // verify bracket count
    if (bracketCount[0] !== bracketCount[1])
      // mismatched generics, could be something scary
      return false;

    // next token should be optional whitespace followed by an ident
    if (!walker.hasNext()) return false;
    var token = walker.next();
    if (token.name === "default") {
      if (!walker.hasNext()) return false;
      token = walker.next();
    }
    return token.name === "ident";
  }),

  // using aliases, e.g. "Foo" in "using Foo = System.Linq.Enumerable;"
  function (context) {
    // previous non-ws token must be "using" and next non-ws token must be "="
    var prevToken = util.getPreviousNonWsToken(context.tokens, context.index);

    if (!prevToken || prevToken.name !== "keyword" || prevToken.value !== "using") return false;

    var nextToken = util.getNextNonWsToken(context.tokens, context.index);
    if (!nextToken || nextToken.name !== "operator" || nextToken.value !== "=") return false;

    return true;
  },

  // attributes (friggin' attributes...)
  createNamedIdentFunction(function (context) {
    {
      // If the next token is an equals sign, this is a named parameter, or
      // something else not inside of an attribute)
      var _token5 = util.getNextNonWsToken(context.tokens, context.index);
      if (_token5 && _token5.name === "operator" && (_token5.value === "=" || _token5.value === ".")) return false;
    }

    // This is annoyingly complicated...
    // We need to verify that we're between [], but not in something like "new
    // string[foo]" for instance

    // first, verify that we're inside an opening bracket
    var bracketCount = [0, 0];
    var walker = context.getTokenWalker();
    while (walker.hasPrev()) {
      var _token6 = walker.prev();
      if (_token6.name !== "punctuation") continue;

      if (_token6.value === "[") {
        bracketCount[0]++;
        continue;
      }

      if (_token6.value === "]") {
        bracketCount[1]++;
        continue;
      }

      // Start of named ident token
      if (_token6.value === "{" || _token6.value === "}" || _token6.value === ";") break;
    }

    // if no brackets were found OR...
    // all the found brackets are closed, so this ident is actually outside of
    // the brackets duh.
    if (bracketCount[0] === 0 || bracketCount[0] === bracketCount[1]) return false;

    // next, verify we're inside a closing bracket
    walker = context.getTokenWalker();
    var indexOfLastBracket = -1;
    while (walker.hasNext()) {
      var _token7 = walker.next();
      if (_token7.name === "punctuation") {
        if (_token7.value === "[") {
          bracketCount[0]++;
          continue;
        }
        if (_token7.value === "]") {
          indexOfLastBracket = walker.index;
          bracketCount[1]++;
          continue;
        }

        // End of named ident token
        if (_token7.value === "{" || _token7.value === "}" || _token7.value === ";") break;
      }
    }

    if (indexOfLastBracket < 0 || bracketCount[0] !== bracketCount[1]) return false;

    // next token after the last closing bracket should be either a keyword or an ident
    var token = util.getNextNonWsToken(context.tokens, indexOfLastBracket);
    if (token && (token.name === "keyword" || token.name === "ident")) return true;

    return false;
  }),

  // fully qualified type names
  createNamedIdentFunction(function (context) {
    // next token is not "."
    var nextToken = util.getNextNonWsToken(context.tokens, context.index);

    if (nextToken && nextToken.name === "operator" && nextToken.value === ".") return false;

    // go backward and make sure that there are only idents and dots before the new keyword
    // "previous" is used to make sure that method declarations like "public new Object Value()..." are treated correctly
    var walker = context.getTokenWalker();
    var previous = walker.current();
    while (walker.hasPrev()) {
      var token = walker.prev();
      if (token.name === "keyword" && (token.value === "new" || token.value === "is")) return true;

      if (token.name === "default") continue;

      if (token.name === "ident") {
        if (previous && previous.name === "ident") return false;

        previous = token;
        continue;
      }

      if (token.name === "operator" && token.value === ".") {
        if (previous && previous.name !== "ident") return false;

        previous = token;
        continue;
      }

      break;
    }

    return false;
  }),

  // casting
  function () {
    var precedes = [[util.whitespace, { token: "punctuation", values: [")"] }, util.whitespace, { token: "ident" }], [util.whitespace, { token: "punctuation", values: [")"] }, util.whitespace, { token: "keyword", values: ["this"] }]];

    return createNamedIdentFunction(function (context) {
      if (!precedes.some(function (precede) {
        return util.IsPrecedesRuleSatisfied(context.getTokenWalker(), precede, false);
      })) return false;

      // make sure the previous tokens are "(" and then not a keyword
      // this'll make sure that things like "if (foo) doSomething();" won't color "foo"
      var walker = context.getTokenWalker();
      while (walker.hasPrev()) {
        var token = walker.prev();
        if (token.name === "punctuation" && token.value === "(") {
          var prevToken = util.getPreviousNonWsToken(context.tokens, walker.index);
          return !prevToken || prevToken.name !== "keyword";
        }
      }

      return false;
    });
  }(),

  // using alias type names, e.g. "Foo" in "using Bar = My.Namespace.Foo;"
  function (context) {
    var nextToken = util.getNextNonWsToken(context.tokens, context.index);
    if (!nextToken || nextToken.name !== "punctuation" || nextToken.value !== ";") return false;

    // should be preceded by idents and dots, and then "using ="
    var walker = context.getTokenWalker();
    while (walker.hasPrev()) {
      var token = walker.prev();
      if (token.name === "ident" || token.name === "default" || token.name === "operator" && token.value === ".") continue;

      // should be an equals sign, and then an ident and then "using"
      if (token.name !== "operator" || token.value !== "=") return false;

      return util.IsFollowsRuleSatisfied(walker, [{ token: "keyword", values: ["using"] }, { token: "default" }, { token: "ident" }, util.whitespace]);
    }

    return false;
  },

  // can't use the follows/precedes utilities since we need to verify that it
  // doesn't match the type definition naming convention
  createNamedIdentFunction(function (context) {
    var follows = [
    // method/property return values
    // special method parameters
    // new: public new Foo Method() { } and new Foo();
    // class/interface/event/struct/delegate names
    [{
      token: "keyword",
      values: ["class", "interface", "event", "struct", "enum", "delegate", "public", "private", "protected", "internal", "static", "virtual", "sealed", "params"]
    }, util.whitespace],

    // typeof/default
    [{ token: "keyword", values: ["typeof", "default"] }, util.whitespace, { token: "punctuation", values: ["("] }, util.whitespace],

    // casting using "as"
    [{ token: "keyword", values: ["as"] }, util.whitespace]];

    var precedes = [
    // arrays
    [util.whitespace, { token: "punctuation", values: ["["] }, util.whitespace, { token: "punctuation", values: ["]"] }], // in method parameters

    // assignment: Object o = new object();
    // method parameters: public int Foo(Foo foo, Bar b, Object o) { }
    [{ token: "default" }, { token: "ident" }]];

    return precedes.some(function (rule) {
      return util.IsPrecedesRuleSatisfied(context.getTokenWalker(), rule, false);
    }) || follows.some(function (rule) {
      return util.IsFollowsRuleSatisfied(context.getTokenWalker(), rule, false);
    });
  })]
};

var operators = exports.operators = [
// arithmetic
"++", "+=", "+", "--", "-=", "-", "*=", "*", "/=", "/", "%=", "%",

// boolean
"&&", "||",

// bitwise
"|=", "|", "&=", "&", "^=", "^", ">>=", ">>", "<<=", "<<",

// inequality
"<=", "<", ">=", ">", "==", "!=",

// unary
"!", "~",

// other
"??", "?", "::", ":", ".", "=>", "="];