"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsPrecedesRuleSatisfied = IsPrecedesRuleSatisfied;
exports.IsFollowsRuleSatisfied = IsFollowsRuleSatisfied;
exports.IsBetweenRuleSatisfied = IsBetweenRuleSatisfied;

var _util = require("./util.js");

/**
 * Evaluate a precedes rule. The token at the index must precede the requirement
 * in the given order.
 * @param {ArrayWalker} walker The walker with the tokens. The walker will be
 *                             mutated.
 * @param {Array} tokenRequirements Array of token requirements, same as
 *                                  namedIdentRules.precedes
 * @param {boolean|undefined} caseInsensitive Indicates whether the token values
 *                                            are case insensitive
 * @returns {boolean}
 */
function IsPrecedesRuleSatisfied(walker, tokenRequirements) {
  var caseInsensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = tokenRequirements[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var expected = _step.value;

      if (!walker.hasNext()) if (expected.optional === true) continue;else return false;

      var actual = walker.next();
      if (actual.name === expected.token && (!expected.values || (0, _util.contains)(expected.values, actual.value, caseInsensitive))) continue;

      if (expected.optional) walker.decreaseIndex();else return false;
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return true;
}

/**
 * Evaluate a follows rule. The token at the index must follow the requirement
 * in the given order.
 * @param {ArrayWalker} walker The walker with the tokens. The walker will be
 *                             mutated.
 * @param {Array} tokenRequirements Array of token requirements, same as
 *                                  namedIdentRules.follows
 * @param {boolean|undefined} caseInsensitive Indicates whether the token values
 *                                            are case insensitive
 * @returns {boolean}
 */
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

function IsFollowsRuleSatisfied(walker, tokenRequirements) {
  var caseInsensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  for (var i = tokenRequirements.length - 1; i >= 0; --i) {
    var expected = tokenRequirements[i];
    if (!walker.hasPrev()) if (expected.optional === true) continue;else return false;

    var actual = walker.prev();
    if (actual.name === expected.token && (!expected.values || (0, _util.contains)(expected.values, actual.value, caseInsensitive))) continue;

    if (expected.optional) walker.increaseIndex();else return false;
  }
  return true;
}

/**
 * Evaluate a between rule.
 * @param {ArrayWalker} walker The walker with the tokens. The walker will be
 *                             mutated.
 * @param {object} opener { token: "tokenName", values: ["token", "values"] }
 * @param {object} closer { token: "tokenName", values: ["token", "values"] }
 * @param {boolean|undefined} caseInsensitive Indicates whether the token values
 *                                            are case insensitive.
 * @returns {boolean}
 */
function IsBetweenRuleSatisfied(walker, opener, closer) {
  var caseInsensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  // check to the left: if we run into a closer or never run into an opener, fail
  var walker1 = walker.duplicate();
  var success = false;
  while (walker1.hasPrev()) {
    var _token = walker1.prev();

    if (_token.name === opener.token && (!opener.values || (0, _util.contains)(opener.values, _token.value, caseInsensitive))) {
      success = true;
      break;
    }

    if (_token.name === closer.token && (!closer.values || (0, _util.contains)(closer.values, _token.value, caseInsensitive))) return false;
  }

  if (!success) return false;

  // check to the right for the closer
  while (walker.hasNext()) {
    var _token2 = walker.next();

    if (_token2.name === closer.token && (!closer.values || (0, _util.contains)(closer.values, _token2.value, caseInsensitive))) return true;

    if (_token2.name === opener.token && (!opener.values || (0, _util.contains)(opener.values, _token2.value, caseInsensitive))) return false;
  }

  return false;
}