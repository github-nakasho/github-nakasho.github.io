"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.IsBetweenRuleSatisfied = exports.IsFollowsRuleSatisfied = exports.IsPrecedesRuleSatisfied = exports.Token = exports.defaultAnalyzer = exports.whitespace = exports.createHashMap = exports.escapeSequences = exports.eol = undefined;
exports.lastElement = lastElement;
exports.lastChar = lastChar;
exports.regexEscape = regexEscape;
exports.clone = clone;
exports.contains = contains;
exports.matchWord = matchWord;

var _languages = require("./languages.js");

Object.defineProperty(exports, "createHashMap", {
  enumerable: true,
  get: function get() {
    return _languages.createHashMap;
  }
});
exports.nonCapturingGroup = nonCapturingGroup;
exports.getRegexpParser = getRegexpParser;
exports.createBetweenRule = createBetweenRule;
exports.createProceduralRule = createProceduralRule;
exports.getNextWhile = getNextWhile;
exports.getNextNonWsToken = getNextNonWsToken;
exports.getPreviousNonWsToken = getPreviousNonWsToken;
exports.getPreviousWhile = getPreviousWhile;
exports.getComputedStyle = getComputedStyle;

var _defaultHelpers = require("./default-helpers.js");

Object.defineProperty(exports, "defaultAnalyzer", {
  enumerable: true,
  get: function get() {
    return _defaultHelpers.defaultAnalyzer;
  }
});

var _token = require("./token.js");

Object.defineProperty(exports, "Token", {
  enumerable: true,
  get: function get() {
    return _token.Token;
  }
});

var _rulesProcessor = require("./rules-processor.js");

Object.defineProperty(exports, "IsPrecedesRuleSatisfied", {
  enumerable: true,
  get: function get() {
    return _rulesProcessor.IsPrecedesRuleSatisfied;
  }
});
Object.defineProperty(exports, "IsFollowsRuleSatisfied", {
  enumerable: true,
  get: function get() {
    return _rulesProcessor.IsFollowsRuleSatisfied;
  }
});
Object.defineProperty(exports, "IsBetweenRuleSatisfied", {
  enumerable: true,
  get: function get() {
    return _rulesProcessor.IsBetweenRuleSatisfied;
  }
});

var _jsdom = require("./jsdom.js");

/* eslint no-magic-numbers: ["error", { "ignore": [-1, 0, 1] }] */
/* eslint flowtype/no-weak-types: "warn" */

/**
 * Gets the last element in an array.
 * @param {Array} arr
 * @returns {*}
 */
function lastElement(arr) {
  return arr[arr.length - 1];
}

/**
 * Gets the last character in a string
 * @param {string} s
 * @returns {string}
 */

function lastChar(s) {
  return s.charAt(s.length - 1);
}

/**
 * Escape a string for the use as a RegExp pattern.
 * See http://stackoverflow.com/questions/3561493/is-there-a-regexp-escape-function-in-javascript/3561711#3561711
 * @param {string} s The string to escape
 * @returns {string}
 */
function regexEscape(s) {
  return s.replace(/[-/\\^$*+?.()|[\]{}]/g, "\\$&");
}

// TODO: remove IE hack
var isIe = !+"\v1";

/**
 * The EOL character ("\r" on IE, "\n" otherwise)
 */
var eol = exports.eol = isIe ? "\r" : "\n";

/**
 * Returns a shallow clone of an object.
 * @param {Object} object
 * @returns {Object}
 */
function clone(object) {
  return Object.assign({}, object);
}

/**
 * Array of default string escape sequences.
 */
var escapeSequences = exports.escapeSequences = ["\\n", "\\t", "\\r", "\\\\", "\\v", "\\f"];

/**
 * Returns if the array contains the value.
 * @param {Array} arr The haystack
 * @param {*} value The needle
 * @param {boolean|undefined} caseInsensitive Set to true to enable case insensitivity.
 * @returns {boolean}
 */
function contains(arr, value) {
  var caseInsensitive = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

  if (!caseInsensitive) return arr.indexOf(value) >= 0;

  return arr.some(function (element) {
    return element === value || caseInsensitive && typeof element === "string" && typeof value === "string" && element.toUpperCase() === value.toUpperCase();
  });
}

/**
 * Determines if a word in the word map matches the current context. This should
 * be used from a custom parse rule.
 * @param {object} context The parse context
 * @param {object} wordMap A hashmap returned by createHashMap
 * @param {string} tokenName The name of the token to create
 * @param {boolean|undefined} doNotRead Whether or not to advance the internal pointer
 * @returns {object} A token returned from context.createToken
 */
function matchWord(context, wordMap, tokenName) {
  var doNotRead = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  wordMap = wordMap || {};

  var current = context.reader.peek();
  if (context.language.caseInsensitive) current = current.toUpperCase();

  if (!wordMap[current]) return null;

  var subMap = wordMap[current];

  var index = subMap.findIndex(function (wordItem) {
    var word = wordItem.value;
    var peek = context.reader.peek(word.length + 1);
    return word === peek || wordItem.regex.test(peek);
  });

  if (index >= 0) return context.createToken(tokenName, doNotRead ? context.reader.peek(subMap[index].value.length) : context.reader.read(subMap[index].value.length));

  return null;
}

/**
 * Return the regex string of non-capturing group with quantifier. i.e.
 * (?:expr1|expr2|...)quantifier. Tip: Put all OR conditions into a
 * non-capturing group before mixing with other expressions. If not, the first
 * or the last condition may be mix with other parts of the regular expression,
 * producing unpredictable results.
 * @param {string | string[]} expressions
 * @param {string?} quantifier
 * @returns {string}
 */
function nonCapturingGroup(expressions) {
  var quantifier = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "";

  var expression = typeof expressions === "string" ? expressions : expressions.join("|");
  return "(?:" + expression + ")" + quantifier;
}

/**
 * Returns a parser from a regular expression. The parser match the content from
 * the index to the end of line against the regular expression.
 * @param {string} tokenName The type of the token returned for successful
 *                           parsing.
 * @param {RegExp} regex The regular expression. The regular expression should
 * always start with `^` to match only the beginning of a string, otherwise it
 * will be inefficient.
 * @returns {function}
 */
function getRegexpParser(tokenName, regex) {
  return function (context) {
    var match = context.reader.peekToEndOfLine().match(regex);
    // Fail if no match or not matching the start of a string.
    if (!match || match.index !== 0) return null;

    return context.createToken(tokenName, context.reader.read(match[0].length));
  };
}

/**
 * Creates a between rule
 *
 * @param {number} startIndex The index at which to start examining the tokens.
 * @param {object} opener { token: "tokenName", values: ["token", "values"] }
 * @param {object} closer { token: "tokenName", values: ["token", "values"] }
 * @param {boolean|undefined} caseInsensitive Indicates whether the token values
 *                                            are case insensitive.
 * @returns {function} Accepts an array of tokens as the single parameter and
 *                     returns a boolean.
 */
function createBetweenRule(startIndex, opener, closer) {
  var caseInsensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  return function (tokens) {
    // check to the left: if we run into a closer or never run into an opener, fail
    var token = void 0;
    var success = false;
    var index = startIndex;
    while ((token = tokens[--index]) !== undefined) {
      if (token.name === opener.token && contains(opener.values, token.value, caseInsensitive)) {
        success = true;
        break;
      }

      if (token.name === closer.token && contains(closer.values, token.value, caseInsensitive)) return false;
    }

    if (!success) return false;

    // check to the right for the closer
    index = startIndex;
    while ((token = tokens[++index]) !== undefined) {
      if (token.name === closer.token && contains(closer.values, token.value, caseInsensitive)) return true;

      if (token.name === opener.token && contains(opener.values, token.value, caseInsensitive)) return false;
    }

    // TODO: Verify because this is suspecious.
    return true;
  };
}

/**
 * Creates a follows or precedes rule
 * @param {number} startIndex The index at which to start examining the tokens.
 * @param {number} direction 1 for follows, -1 for precedes
 * @param {Array} tokenRequirements Array of token requirements, same as namedIdentRules.follows
 * @param {boolean|undefined} caseInsensitive Indicates whether the token values are case insensitive
 * @returns {function} Accepts an array of tokens as the single parameter and returns a boolean
 */
function createProceduralRule(startIndex, direction, tokenRequirements) {
  var caseInsensitive = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;

  tokenRequirements = tokenRequirements.slice(0); // clone array
  if (direction === 1) tokenRequirements.reverse();

  return function (tokens) {
    var tokenIndexStart = startIndex;

    for (var j = 0; j < tokenRequirements.length; j++) {
      var actual = tokens[tokenIndexStart + j * direction];
      var expected = tokenRequirements[tokenRequirements.length - 1 - j];

      if (actual === undefined) {
        if (expected.optional !== undefined && expected.optional) tokenIndexStart -= direction;else return false;
      } else if (actual.name === expected.token && (expected.values === undefined || contains(expected.values, actual.value, caseInsensitive)))
        // derp
        continue;else if (expected.optional !== undefined && expected.optional) tokenIndexStart -= direction; // we need to reevaluate against this token again
      else return false;
    }

    return true;
  };
}

/**
 * Gets the next token in the specified direction while matcher matches the
 * current token.
 * @param {Token[]} tokens Array of tokens
 * @param {number} index The index at which to start
 * @param {number} direction The direction to search: 1 = forward, -1 = backward
 * @param {function} matcher Predicate for determining if the token matches
 * @returns {Token?} The token or undefined
 */
function getNextWhileInternal(tokens, index, direction, matcher) {
  direction = direction || 1;
  var count = 1;
  var token = void 0;
  while (token = tokens[index + direction * count++]) {
    if (!matcher(token)) return token;
  }return undefined;
}

/**
 * Gets the next token while the matcher returns true.
 * @param {Token[]} tokens Array of tokens
 * @param {number} index The index at which to start
 * @param {function} matcher Predicate for determining if the token matches
 * @returns {Token?} The token or undefined
 */
function getNextWhile(tokens, index, matcher) {
  return getNextWhileInternal(tokens, index, 1, matcher);
}

/**
 * Gets the next non-whitespace token. This is not safe for looping.
 * @param {Token[]} tokens Array of tokens
 * @param {number} index  The index at which to start
 * @returns {Token?} The token or undefined
 */
function getNextNonWsToken(tokens, index) {
  return getNextWhileInternal(tokens, index, 1, function (token) {
    return token.name === "default";
  });
}

/**
 * Gets the previous non-whitespace token. This is not safe for looping.
 * @param {Token[]} tokens Array of tokens
 * @param {number} index  The index at which to start
 * @returns {Object} The token or undefined
 */
function getPreviousNonWsToken(tokens, index) {
  return getNextWhileInternal(tokens, index, -1, function (token) {
    return token.name === "default";
  });
}

/**
 * Gets the previous token while the matcher returns true.
 * @param {Token[]} tokens Array of tokens
 * @param {number} index The index at which to start
 * @param {function} matcher Predicate for determining if the token matches
 * @returns {Object} The token or undefined
 */
function getPreviousWhile(tokens, index, matcher) {
  return getNextWhileInternal(tokens, index, -1, matcher);
}

/**
 * An object to be used in named ident rules to indicate optional whitespace
 */
var whitespace = exports.whitespace = { token: "default", optional: true };

/**
 * Gets the computed style of the element
 * Adapted from http://blargh.tommymontgomery.com/2010/04/get-computed-style-in-javascript/
 * @param {HTMLElement} element A DOM element
 * @param {string} style The name of the CSS style to retrieve
 * @returns {string}
 */
function getComputedStyle(element, style) {
  var func = null;
  if (_jsdom.document.defaultView && _jsdom.document.defaultView.getComputedStyle) func = _jsdom.document.defaultView.getComputedStyle;else func = function func(element) {
    // TODO: Remove (IE compatibility)
    return element.currentStyle || {};
  };

  return func(element)[style];
}