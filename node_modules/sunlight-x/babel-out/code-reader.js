"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});


/* eslint no-magic-numbers: 1 */

class CodeReader {

  constructor(text) {
    this.index = 0;

    // Normalize line endings to unix
    this.text = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
    this.length = this.text.length;
  }

  peek() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    return this.text.substr(this.index, count);
  }

  peekWithOffset(relativeIndex) {
    var count = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

    if (count < 1) return "";
    var index = this.index + relativeIndex;
    return this.text.substring(index, index + count);
  }

  peekToEOF() {
    return this.text.substring(this.index);
  }

  peekToEndOfLine() {
    var startIndex = this.index;
    var endIndex = this.text.indexOf("\n", startIndex);
    if (endIndex >= 0) return this.text.substring(startIndex, endIndex);
    return this.text.substring(startIndex);
  }

  read() {
    var count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

    var ret = this.peek(count);
    // Advance index by the actual number of characters read, so it doesn't go
    // past the end of the text.
    this.index += ret.length;
    return ret;
  }

  isEOF() {
    return this.index >= this.length;
  }

  isStartOfLine() {
    return this.index === 0 || this.peekWithOffset(-1) === "\n";
  }

  // Check if the current character is preceded by whitespace or nothing.
  isPrecededByWhitespaceOnly() {
    for (var offset = -1;; offset--) {
      var peek = this.peekWithOffset(offset);
      if (peek === "" || peek === "\n") break;
      if (!/\s/.test(peek)) return false;
    }
    return true;
  }

  // TODO: rename to "match" after migration.
  match(str) {
    return this.text.substr(this.index, str.length) === str;
  }
}
exports.CodeReader = CodeReader;