'use strict';

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _sunlightX = require('sunlight-x');

var _langMapping = require('./lang-mapping.js');

var pluginName = 'Sunlight-highlighter';

var defaultLineNumbers = void 0;
var defaultTheme = void 0;
var log = void 0;

/**
 * Sanitize the name of the theme. Returns the name if it is alphanumeric.
 * Otherwise returns "gitbook", i.e. the default theme.
 * @param {string} name The name of theme to be validated.
 * @returns {string}
 */
function SanitizeTheme(name) {
  if (/^[0-9A-Za-z]*$/.test(name)) return name;
  return 'gitbook';
}

/**
 * Loads the options in book.json or book.js. These options are used unless
 * overriden by a per-page/per-script option.
 * @param {Object} options Pass this.options to this parameter.
 */
function loadDefaultOptions(options) {
  var pluginOptions = options.pluginsConfig['sunlight-highlighter'];

  defaultLineNumbers = pluginOptions.lineNumbers;

  var theme = SanitizeTheme(pluginOptions.theme);
  defaultTheme = theme;
}

/**
 * Log an error
 @param {string} message
 */
function logError(message) {
  log.error.ln(`${pluginName}: ${message}`);
}

/**
 * Parse the options
 * @param {sting[]} optionList The list of options. Each option is formatted in
 * "key:value". Examples are "theme:gitbook", "lineNumbers:true", and
 * "lineNumberStart:10".
 * @returns {Object} Key-value pairs of options.
 */
function parseOptions(optionList) {
  var options = {};
  options.lineNumbers = defaultLineNumbers;
  options.lineNumberStart = 1;

  var _iteratorNormalCompletion = true;
  var _didIteratorError = false;
  var _iteratorError = undefined;

  try {
    for (var _iterator = optionList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
      var optionItem = _step.value;

      var _optionItem$split = optionItem.split(':', 2),
          _optionItem$split2 = _slicedToArray(_optionItem$split, 2),
          key = _optionItem$split2[0],
          value = _optionItem$split2[1];

      switch (key) {
        case 'theme':
          if (/^[A-Za-z0-9_-]*$/.test(value)) options[key] = SanitizeTheme(value);else logError(`Invalid theme: ${key}`);
          break;
        case 'lineNumbers':
          if (value === 'true' || value === 'false') options[key] = value === 'true';else logError(`lineNumbers must be true or false. Given value: ${value}`);
          break;
        case 'lineNumberStart':
          if (/^[0-9]+$/.test(value)) options[key] = Number.parseInt(value);else logError(`lineNumberStart must be a non-negative integer. Given value: ${value}`);
          break;
        default:
          logError(`Unknown options: ${key}`);
      }
    }
  } catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
  } finally {
    try {
      if (!_iteratorNormalCompletion && _iterator.return) {
        _iterator.return();
      }
    } finally {
      if (_didIteratorError) {
        throw _iteratorError;
      }
    }
  }

  return options;
}

/**
 * Highlight the code block.
 * @param {string|undefined} lang The language and other parameter.
 * @param {string|undefined} code The code to be highlighted.
 * @returns {string} The highlighted HTML code.
 */
function highlight(lang, code) {
  if (!lang || lang === 'nohighlight') return { body: code, html: false };

  var optionData = lang.replace(' ', '').split('+');
  lang = (0, _langMapping.SanitizeLanguage)(optionData.shift());
  var options = parseOptions(optionData);
  if (!options.hasOwnProperty('theme')) options.theme = defaultTheme;

  try {
    var highlighter = new _sunlightX.Highlighter(options);

    return highlighter.highlightCode(code, lang);
  } catch (e) {
    log.error(e);
  }

  return { body: code, html: false };
}

module.exports = {
  book: {
    assets: 'compiled-assets',
    css: ['sunlight.css']
  },
  ebook: {
    assets: 'compiled-assets',
    css: ['sunlight.css']
  },
  blocks: {
    code: function code(block) {
      return highlight(block.kwargs.language, block.body);
    }
  },
  hooks: {
    init: function init() {
      loadDefaultOptions(this.options);
      log = this.log;
    }
  }
};