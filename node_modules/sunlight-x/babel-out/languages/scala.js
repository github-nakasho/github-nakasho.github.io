"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.contextItems = exports.namedIdentRules = exports.customParseRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.embeddedLanguages = exports.keywords = exports.name = undefined;

var _events = require("../events.js");

var events = _interopRequireWildcard(_events);

var _logger = require("../logger.js");

var logger = _interopRequireWildcard(_logger);

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var name = exports.name = "scala"; // sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var keywords = exports.keywords = ["abstract", "case", "catch", "class", "def", "do", "else", "extends", "false", "final", "finally", "forSome", "for", "if", "implicit", "import", "lazy", "match", "new", "null", "object", "override", "package", "private", "protected", "return", "sealed", "super", "this", "throw", "trait", "try", "true", "type", "val", "var", "while", "with", "yield"];

var embeddedLanguages = exports.embeddedLanguages = {
  xml: {
    switchTo: function switchTo(context) {
      context.items.literalXmlNestingLevel = 0;

      if (context.reader.peek() !== "<" || !/[\w!?]/.test(context.reader.peekWithOffset(1))) return false;

      if (context.defaultData.text !== "")
        // preceded by whitespace
        return true;

      var prevToken = context.token(context.count() - 1);
      return prevToken && prevToken.name === "punctuation" && util.contains(["(", "{"], prevToken.value);
    },

    switchBack: function switchBack(context) {
      var prevToken = context.token(context.count() - 1);
      if (!prevToken) return false;

      if (typeof context.items.literalXmlNestingLevel !== "number") {
        logger.errorInvalidValue(`literalXmlNestingLevel is not a number.`, context.items.literalXmlNestingLevel);
        return true;
      }

      if (prevToken.name === "tagName") {
        if (!context.items.literalXmlOpenTag) context.items.literalXmlOpenTag = prevToken.value;
      } else if (prevToken.name === "operator") {
        switch (prevToken.value) {
          case "<":
            context.items.literalXmlNestingLevel++;
            break;
          case "</":
          case "/>":
            context.items.literalXmlNestingLevel--;
            break;
        }
      }

      if (context.items.literalXmlOpenTag && context.items.literalXmlNestingLevel === 0 && (prevToken.value === ">" || prevToken.value === "/>")) return true;

      return false;
    }
  }
};

var scopes = exports.scopes = {
  string: [['"""', '"""', [], false], ['"', '"', ["\\\\", '\\"'], false]],
  char: [["'", "'", ["\\\\", "\\'"], false]],
  quotedIdent: [["`", "`", ["\\`", "\\\\"], false]],
  comment: [["//", "\n", [], true], ["/*", "*/", [], false]],
  annotation: [["@", { length: 1, regex: /\W/ }, [], true]]
};

var identFirstLetter = exports.identFirstLetter = /[A-Za-z]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/;

var customParseRules = exports.customParseRules = [
// symbol literals
function (context) {
  if (!context.reader.match("'")) return null;

  // TODO: don't use regular expression.
  var match = /^('\w+)(?!')/i.exec(context.reader.peekToEOF());
  if (!match) return null;
  context.reader.read(match[1].length);

  return context.createToken("symbolLiteral", match[1]);
},

// case classes: can't distinguish between a case class and a function call so
// we need to keep track of them
function (context) {
  if (context.defaultData.text === "") return null;

  if (!/[A-Za-z]/.test(context.reader.peek())) return null;

  var prevToken = context.token(context.count() - 1);
  if (!prevToken || prevToken.name !== "keyword" || !util.contains(["class", "type", "trait", "object"], prevToken.value)) return null;

  // read the ident
  var ident = context.reader.read();
  while (!context.reader.isEOF() && /\w/.test(context.reader.peek())) {
    ident += context.reader.read();
  }context.userDefinedNameStore.addName(ident, name);
  return context.createToken("ident", ident);
}];

var namedIdentRules = exports.namedIdentRules = {
  custom: [
  // some built in types
  function () {
    var builtInTypes = ["Nil", "Nothing", "Unit", "Pair", "Map", "String", "List", "Int", "Seq", "Option", "Double", "AnyRef", "AnyVal", "Any", "ScalaObject", "Float", "Long", "Short", "Byte", "Char", "Boolean"];

    return function (context) {
      // next token is not "."
      var nextToken = util.getNextNonWsToken(context.tokens, context.index);
      if (nextToken && nextToken.name === "operator" && nextToken.value === ".") return false;

      return util.contains(builtInTypes, context.tokens[context.index].value);
    };
  }(),

  // user-defined types
  function (context) {
    return context.userDefinedNameStore.hasName(context.tokens[context.index].value, name);
  },

  // fully qualified type names after "new"
  function (context) {
    // TODO: add test. The while loop is untested.

    // The next token must not be "."
    var nextToken = util.getNextNonWsToken(context.tokens, context.index);
    if (nextToken && nextToken.name === "operator" && nextToken.value === ".") return false;

    // Go backward and check that if there are only idents and dots after the
    // new keyword.
    var walker = context.getTokenWalker();
    var previousIsIdent = true; // the current token is an ident
    while (walker.hasPrev()) {
      var token = walker.prev();

      if (token.name === "keyword" && token.value === "new") return true;

      if (token.name === "default") continue;

      if (token.name === "ident") {
        if (previousIsIdent) return false;

        previousIsIdent = true;
        continue;
      }

      if (token.name === "operator" && token.value === ".") {
        if (!previousIsIdent) return false;

        previousIsIdent = false;
        continue;
      }

      break;
    }

    return false;
  }, function () {
    var follows = [[{
      token: "keyword",
      values: ["class", "object", "extends", "new", "type", "trait"]
    }, { token: "default" }], [{ token: "operator", values: [":"] }, util.whitespace], [{ token: "operator", values: ["#"] }], [{ token: "keyword", values: ["type"] }, { token: "default" }, { token: "ident" }, util.whitespace, { token: "operator", values: ["="] }, util.whitespace]];
    var between = [
    // generics
    {
      opener: { token: "punctuation", values: ["["] },
      closer: { token: "punctuation", values: ["]"] }
    }];

    return function (context) {
      // generic type names are assumed to start with a capital letter
      // optionally followed by a number or another capital letter e.g. A, T1,
      // TFrom, etc.
      if (/^[A-Z]([A-Z0-9]\w*)?$/.test(context.tokens[context.index].value)) return false;

      return follows.some(function (rule) {
        return util.IsFollowsRuleSatisfied(context.getTokenWalker(), rule, false);
      }) || between.some(function (rule) {
        return util.IsBetweenRuleSatisfied(context.getTokenWalker(), rule.opener, rule.closer, false);
      });
    };
  }()]
};

var contextItems = exports.contextItems = {
  literalXmlOpenTag: null,
  literalXmlNestingLevel: 0
};

var operators = exports.operators = ["++", "+=", "+", "--", "-=", "->", "-", "*=", "*", "^=", "^^", "^", "~>", "~", "!=", "!", "&&", "&=", "&", "||", "|=", "|", ">>>", ">>=", ">>", ">", "<<=", "<<", "<~", "<=", "<%", "<", "%>", "%=", "%", "::", ":<", ":>", ":", "==", "=", "@", "#", "_", "."];

events.BeforeHighlightEvent.addListener(function (highlighter, context) {
  if (context.language.name === "scala") highlighter.options.enableScalaXmlInterpolation = true;
});

events.AfterHighlightEvent.addListener(function (highlighter) {
  highlighter.options.enableScalaXmlInterpolation = false;
});