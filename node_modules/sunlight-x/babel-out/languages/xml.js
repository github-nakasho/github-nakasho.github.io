"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.contextItems = exports.embeddedLanguages = exports.customParseRules = exports.customTokens = exports.numberParser = exports.punctuation = exports.scopes = exports.caseInsensitive = exports.name = undefined;

var _logger = require("../logger.js");

var logger = _interopRequireWildcard(_logger);

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * See if |context| is inside an open bracket.
 * @param {ParserContext} context
 * @returns {boolean}
 */
function isInsideOpenBracket(context) {
  var walker = context.getTokenWalker();
  while (walker.hasPrev()) {
    var token = walker.prev();
    if (token.name === "operator" && (token.value === ">" || token.value === "/>" || token.value === "</")) return false;

    if (token.name === "tagName" || token.name === "xmlOpenTag") return true;
  }

  return false;
}

var name = exports.name = "xml";

var caseInsensitive = exports.caseInsensitive = true;

var scopes = exports.scopes = {
  comment: [["<!--", "-->", [], false], ["<%--", "--%>", [], false]],
  cdata: [["<![CDATA[", "]]>", [], false]],
  doctype: [["<!DOCTYPE", ">", [], false]]
};

var punctuation = exports.punctuation = /(?!x)x/;
var numberParser = exports.numberParser = function numberParser() {};

var customTokens = exports.customTokens = {
  xmlOpenTag: { values: ["<?xml"], boundary: "" },
  xmlCloseTag: { values: ["?>"], boundary: "" },
  aspOpenTag: { values: ["<%@", "<%$", "<%#", "<%=", "<%"], boundary: "" },
  aspCloseTag: { values: ["%>"], boundary: "" }
};

var customParseRules = exports.customParseRules = [
// tag names
function (context) {
  if (!/[A-Za-z_]/.test(context.reader.peek())) return null;

  var prevToken = context.token(context.count() - 1);
  if (!prevToken || prevToken.name !== "operator" || !util.contains(["<", "</"], prevToken.value)) return null;

  // read the tag name
  var tagName = context.reader.read();
  // allow periods in tag names so that ASP.NET web.config files
  // work correctly
  while (!context.reader.isEOF() && /[.\w-]/.test(context.reader.peek())) {
    tagName += context.reader.read();
  }return context.createToken("tagName", tagName);
},

// strings (attribute values)
function (context) {
  var delimiter = context.reader.peek();
  if (delimiter !== '"' && delimiter !== "'") return null;
  if (!isInsideOpenBracket(context)) return null;

  // read until the delimiter
  var stringValue = context.reader.read();
  while (!context.reader.isEOF()) {
    var next = context.reader.read();
    stringValue += next;

    if (next === delimiter) break;
  }

  return context.createToken("string", stringValue);
},

// attributes
function (context) {
  if (!/[A-Za-z_]/.test(context.reader.peek())) return null;

  // must be between < and >
  if (!isInsideOpenBracket(context)) return null;

  // look forward for >
  var offset = void 0;
  var tokenLength = 0;
  for (offset = 1;; offset++) {
    var peek = context.reader.peekWithOffset(offset);
    if (peek === "" || peek === "<") return null;
    if (peek === ">") {
      if (!tokenLength) tokenLength = offset;
      break;
    }
    if (!tokenLength && /[=\s:]/.test(peek)) tokenLength = offset;
  }

  return context.createToken("attribute", context.reader.read(tokenLength));
},

// entities
function (context) {
  if (!context.reader.match("&")) return null;

  for (var offset = 1;; offset++) {
    var peek = context.reader.peekWithOffset(offset);
    if (peek === "") return null;
    if (peek === ";") return context.createToken("entity", context.reader.read(offset + 1));
    if (!/[A-Za-z0-9]/.test(peek)) return null;
  }
},

// asp.net server side comments: <%-- --%>
function (context) {
  var startAspToken = "<%--";
  var endAspToken = "--%>";
  // have to do these manually or else they get swallowed by the open tag: <%
  if (!context.reader.match(startAspToken)) return null;

  var value = context.reader.read(startAspToken.length);

  while (!context.reader.isEOF() && !context.reader.match(endAspToken)) {
    value += context.reader.read();
  }value += context.reader.read(endAspToken.length);

  return context.createToken("comment", value);
}];

var embeddedLanguages = exports.embeddedLanguages = {
  css: {
    switchTo: function switchTo(context) {
      if (context.options.enableScalaXmlInterpolation === true) return false;

      if (context.reader.match("</style")) return false;

      var walker = context.getTokenWalker();
      if (!walker.hasPrev()) return false;
      var prevToken = walker.prev();

      if (prevToken.name !== "operator" || prevToken.value !== ">") return false;

      // look backward for a tag name, if it's "style", then we go to css mode
      while (walker.hasPrev()) {
        var _prevToken = walker.prev();
        if (_prevToken.name === "tagName") {
          if (_prevToken.value === "style") {
            // make sure it's not a closing tag
            if (!walker.hasPrev()) break;
            var _prevToken2 = walker.prev();
            if (_prevToken2.name === "operator" && _prevToken2.value === "<") return true;
          }
          break;
        }
      }
      return false;
    },

    switchBack: function switchBack(context) {
      return context.reader.match("</style");
    }
  },

  javascript: {
    switchTo: function switchTo(context) {
      if (context.reader.match("</script")) return false;

      var walker = context.getTokenWalker();
      if (!walker.hasPrev()) return false;
      var prevToken = walker.prev();

      if (prevToken.name !== "operator" || prevToken.value !== ">") return false;

      // look backward for a tag name, if it's "script", then we go to javascript mode
      while (walker.hasPrev()) {
        var _prevToken3 = walker.prev();
        if (_prevToken3.name === "tagName") {
          if (_prevToken3.value === "script") {
            // make sure it's not a closing tag
            if (!walker.hasPrev()) break;
            var _prevToken4 = walker.prev();
            if (_prevToken4 && _prevToken4.name === "operator" && _prevToken4.value === "<") return true;
          }
          break;
        }
      }
      return false;
    },

    switchBack: function switchBack(context) {
      return context.reader.match("</script");
    }
  },

  php: {
    switchTo: function switchTo(context) {
      return context.reader.match("<?") && !context.reader.match("<?xml");
    },

    switchBack: function switchBack(context) {
      var prevToken = context.token(context.count() - 1);
      return prevToken && prevToken.name === "closeTag";
    }
  },

  csharp: {
    switchTo: function switchTo(context) {
      var prevToken = context.token(context.count() - 1);
      return prevToken && prevToken.name === "aspOpenTag";
    },

    switchBack: function switchBack(context) {
      return context.reader.match("%>");
    }
  },

  scala: {
    switchTo: function switchTo(context) {
      context.items.scalaBracketNestingLevel = 0;
      return context.options.enableScalaXmlInterpolation === true && context.reader.match("{");
    },

    switchBack: function switchBack(context) {
      var prevToken = context.token(context.count() - 1);

      if (typeof context.items.scalaBracketNestingLevel !== "number") {
        logger.errorInvalidValue(`scalaBracketNestingLevel is not a number.`, context.items.scalaBracketNestingLevel);
        return true;
      }

      if (prevToken.name === "punctuation") if (prevToken.value === "{") {
        context.items.scalaBracketNestingLevel++;
      } else if (prevToken.value === "}") {
        context.items.scalaBracketNestingLevel--;
        if (context.items.scalaBracketNestingLevel === 0) return true;
      }

      return false;
    }
  }
};

var contextItems = exports.contextItems = {
  scalaBracketNestingLevel: 0
};

var operators = exports.operators = ["=", "/>", "</", "<", ">", ":"];