"use strict";

var _constants = require("../constants.js");

var _events = require("../events.js");

var _globalOptions = require("../globalOptions.js");

var _logger = require("../logger.js");

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

var _jsdom = require("../jsdom.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/**
 * Sunlight line number/line highlighting plugin
 *
 * This creates the line number gutter in addition to creating the line highlighting
 * overlay (if applicable). It is bundled in sunlight-min.js.
 *
 * Options:
 *  - lineNumbers: true/false/"automatic" (default is "automatic")
 *  - lineNumberStart: <number> (line number to start from, default is 1)
 *  - lineHighlight: <array> (array of line numbers to highlight)
 */

var defaultLineNumberOptions = {
  lineNumbers: false, // TODO: was "automatic"
  lineNumberStart: 1,
  lineHighlight: []
};
var eolElement = _jsdom.document.createTextNode(util.eol);

/**
 * Get line numbering options from Sunlight highlighter options, and do
 * validation. Invalid options are logged.
 * @param {SunlightOptionsType} options
 * @returns {LineNumberOptionsType}
 */
function getLineNumberOptions(options) {
  var logger = console;
  var parsedOptions = Object.assign({}, defaultLineNumberOptions);

  if (typeof options.lineNumbers === "boolean") parsedOptions.lineNumbers = options.lineNumbers;else (0, _logger.warnInvalidValue)("Option lineNumbers must be boolean.", options.lineNumbers);

  if (
  // TODO: remove typeof check when Flow issue #4441 is resolved.
  typeof options.lineNumberStart === "number" && Number.isInteger(options.lineNumberStart) && options.lineNumberStart >= 0) parsedOptions.lineNumberStart = options.lineNumberStart;else (0, _logger.warnInvalidValue)("Option lineNumberStart must be a non-negative integer.", options.lineNumberStart);

  if (Array.isArray(options.lineHighlight)) {
    // TODO: remove typeof check when Flow issue #4441 is resolved.
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = options.lineHighlight[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var line = _step.value;

        if (typeof line === "number" && Number.isInteger(line) && line >= 0) {
          if (parsedOptions.lineHighlight.indexOf(line) >= 0) parsedOptions.lineHighlight.push(line);else logger.warn("Duplicate elements in option lineHighlight found.", line);
        } else logger.warn("Elements of option lineHighlight must be a non-negative integer.", line);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    parsedOptions.lineHighlight.sort();
  } else {
    logger.warn("Option lineHighlight must be an array of non-negative integers.", options.lineHighlight);
  }

  return parsedOptions;
}

/**
 * Get the line count
 * TODO: rewrite in non-functional manner.
 * @param {Element} node
 * @returns {number}
 */
function getLineCount(node) {
  // browsers don't render the last trailing newline, so we make sure that the
  // line numbers reflect that by disregarding the last trailing newline

  // get the last text node
  var lastTextNode = function getLastNode(node) {
    if (!node.lastChild) return null;
    if (node.lastChild.nodeType === _constants.TEXT_NODE) return node.lastChild;
    return getLastNode(node.lastChild);
  }(node) || { nodeValue: "" };

  return node.innerHTML.replace(/[^\n]/g, "").length - (/\n$/.test(lastTextNode.nodeValue) ? 1 : 0);
}

/**
 * Add line numbers to the highlighted nodes, if configured to do so.
 * @param {Highlighter} highlighter
 * @param {Object} context
 */
function maybeAddLineNumbers(highlighter, context) {
  var codeContainer = context.codeContainer;
  if (!codeContainer) return;

  var options = getLineNumberOptions(highlighter.options);
  if (!options.lineNumbers) return;

  // Skip if it's not a block level element or the lineNumbers option is not set
  // to "automatic"
  if (highlighter.options.lineNumbers === "automatic" && util.getComputedStyle(context.node, "display") !== "block") return;

  var lineHighlightOverlay = _jsdom.document.createElement("div");
  var lineHighlightingEnabled = options.lineHighlight.length > 0;
  if (lineHighlightingEnabled) lineHighlightOverlay.className = highlighter.options.classPrefix + "line-highlight-overlay";

  var lineContainer = _jsdom.document.createElement("div");
  lineContainer.className = highlighter.options.classPrefix + "line-number-margin";

  var lineCount = getLineCount(context.node);
  for (var i = options.lineNumberStart; i <= options.lineNumberStart + lineCount; ++i) {
    var link = _jsdom.document.createElement("a");
    var name = (context.node.id ? context.node.id : highlighter.options.classPrefix + context.count) + "-line-" + i;

    link.setAttribute("name", name);
    link.setAttribute("href", "#" + name);

    link.appendChild(_jsdom.document.createTextNode(i.toString()));
    lineContainer.appendChild(link);
    lineContainer.appendChild(eolElement.cloneNode(false));

    if (lineHighlightingEnabled) {
      var currentLineOverlay = _jsdom.document.createElement("div");
      if (options.lineHighlight.indexOf(i) >= 0) currentLineOverlay.className = highlighter.options.classPrefix + "line-highlight-active";

      lineHighlightOverlay.appendChild(currentLineOverlay);
    }
  }

  codeContainer.insertBefore(lineContainer, codeContainer.firstChild);

  if (lineHighlightingEnabled) codeContainer.appendChild(lineHighlightOverlay);

  // enable the border on the code container
  codeContainer.style.borderWidth = "1px";
  codeContainer.style.borderStyle = "solid";
}

// Initialization of plugin
_events.AfterHighlightNodeEvent.addListener(maybeAddLineNumbers);

Object.assign(_globalOptions.globalOptions, defaultLineNumberOptions);