"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.customTokens = exports.keywords = exports.name = exports.acceptableKeywords = exports.primitives = undefined;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var primitives = exports.primitives = ["int", "char", "void", "long", "signed", "unsigned", "double", "bool", "typename", "class", "short", "wchar_t", "struct"]; // sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var acceptableKeywords = exports.acceptableKeywords = ["int", "char", "void", "long", "signed", "unsigned", "double", "bool", "typename", "class", "short", "wchar_t"];

var name = exports.name = "cpp";

// http://www.cppreference.com/wiki/keywords/start
var keywords = exports.keywords = ["and", "default", "noexcept", "template", "and_eq", "delete", "not", "this", "alignof", "double", "not_eq", "thread_local", "asm", "dynamic_cast", "nullptr", "throw", "auto", "else", "operator", "true", "bitand", "enum", "or", "try", "bitor", "explicittodo", "or_eq", "typedef", "bool", "export", "private", "typeid", "break", "externtodo", "protected", "typename", "case", "false", "public", "union", "catch", "float", "register", "using", "char", "for", "reinterpret_cast", "unsigned", "char16_t", "friend", "return", "void", "char32_t", "goto", "short", "wchar_t", "class", "if", "signed", "virtual", "compl", "inline", "sizeof", "volatile", "const", "int", "static", "while", "constexpr", "long", "static_assert", "xor", "const_cast", "mutable", "static_cast", "xor_eq", "continue", "namespace", "struct", "decltype", "new", "switch"];

var customTokens = exports.customTokens = {
  constant: {
    values: ["EXIT_SUCCESS", "EXIT_FAILURE", "SIG_DFL", "SIG_IGN", "SIG_ERR", "SIGABRT", "SIGFPE", "SIGILL", "SIGINT", "SIGSEGV", "SIGTERM"],
    boundary: "\\b"
  },

  // http://www.cppreference.com/wiki/utility/types/start
  basicType: {
    values: ["ptrdiff_t", "size_t", "nullptr_t", "max_align_t"],
    boundary: "\\b"
  },

  ellipsis: {
    values: ["..."],
    boundary: ""
  }
};

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false]],
  char: [["'", "'", ["\\'", "\\\\"], false]],
  comment: [["//", "\n", [], true], ["/*", "*/", [], false]],
  preprocessorDirective: [["#", "\n", [], true]]
};

var identFirstLetter = exports.identFirstLetter = /[A-Za-z_]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/;

var namedIdentRules = exports.namedIdentRules = {
  custom: [
  // pointer default declarations, e.g. pointer* myPointer;
  function () {
    var precedes = [[util.whitespace, { token: "operator", values: ["*", "**"] }, { token: "default" }, { token: "ident" }, util.whitespace, { token: "punctuation", values: [";"] }], [
    // function parameters
    { token: "default" }, { token: "operator", values: ["&"] }, util.whitespace, { token: "ident" }]];

    return function (context) {
      // basically, can't be on the right hand side of an equals sign
      // so we traverse the tokens backward, and if we run into a "=" before a ";" or a "{", it's no good
      if (!precedes.some(function (precede) {
        return util.IsPrecedesRuleSatisfied(context.getTokenWalker(), precede, false);
      })) return false;

      // make sure we're not on the left side of the equals sign
      var walker = context.getTokenWalker();
      while (walker.hasPrev()) {
        var token = walker.prev();
        if (token.name === "punctuation" && (token.value === ";" || token.value === "{")) return true;

        if (token.name === "operator" && token.value === "=") return false;
      }

      return false;
    };
  }(),

  // casting
  function () {
    var precedes = [[util.whitespace, { token: "punctuation", values: [")"] }, util.whitespace, { token: "ident" }], [{ token: "operator", values: ["*", "**"] }, util.whitespace, { token: "punctuation", values: [")"] }, util.whitespace, { token: "operator", values: ["&"], optional: true }, { token: "ident" }]];

    return function (context) {
      if (!precedes.some(function (precede) {
        return util.IsPrecedesRuleSatisfied(context.getTokenWalker(), precede, false);
      })) return false;

      // make sure the previous tokens are "(" and then not a keyword
      // this'll make sure that things like "if (foo) doSomething();" won't color "foo"
      var walker = context.getTokenWalker();
      while (walker.hasPrev()) {
        var token = walker.prev();
        if (token.name === "punctuation" && token.value === "(") {
          var prevToken = util.getPreviousNonWsToken(context.tokens, walker.index);
          if (prevToken && prevToken.name === "keyword") return false;

          return true;
        }
      }

      return false;
    };
  }(),

  // generic definitions/params between "<" and ">"
  function (context) {
    // between < and > and preceded by an ident and not preceded by "class"

    // if the previous token is a keyword, then we don't care about it
    var prevToken = util.getPreviousNonWsToken(context.tokens, context.index);
    if (!prevToken || prevToken.name === "keyword") return false;

    // look for "<" preceded by an ident but not "class"
    // if we run into ">" before "," or "<" then it's a big fail
    var foundIdent = false;
    var bracketCountLeft = [0, 0];
    var walker = context.getTokenWalker();
    while (walker.hasPrev()) {
      var token = walker.prev();
      if (token.name === "keyword" && token.value === "class")
        // this must be a generic class type definition, e.g. Foo<T>, and we don't want to color the "T"
        return false;

      if (token.name === "operator") {
        switch (token.value) {
          case "<":
          case "<<":
            bracketCountLeft[0] += token.value.length;
            break;
          case ">":
          case ">>":
            if (bracketCountLeft[0] === 0) return false;

            bracketCountLeft[1] += token.value.length;
            break;
          case ".":
            // allows generic method invocations, like "Foo" in "foo.Resolve<Foo>()"
            break;
          default:
            return false;
        }

        continue;
      }

      if (token.name === "keyword" && util.contains(acceptableKeywords, token.value) || token.name === "default" || token.name === "punctuation" && token.value === ",") continue;

      if (token.name === "ident") {
        foundIdent = true;
        continue;
      }

      // anything else means we're no longer in a generic definition
      break;
    }

    if (!foundIdent || bracketCountLeft[0] === 0)
      // not inside a generic definition
      return false;

    // now look forward to make sure the generic definition is closed
    // this avoids false positives like "foo < bar"
    var walker2 = context.getTokenWalker();
    while (walker2.hasNext()) {
      var _token = walker.next();
      if (_token.name === "operator" && (_token.value === ">" || _token.value === ">>")) return true;

      if (_token.name === "keyword" && util.contains(acceptableKeywords, _token.value) || _token.name === "operator" && util.contains(["<", "<<", ">", ">>"], _token.value) || _token.name === "punctuation" && _token.value === "," || _token.name === "ident" || _token.name === "default") continue;

      return false;
    }

    return false;
  },

  // ident before generic definitions, e.g. "foo" in "foo<bar>"
  function (context) {
    // if it's preceded by an ident or a primitive/alias keyword then it's no good (i.e. a generic method definition like "public void Foo<T>")
    // also a big fail if it is preceded by a ., i.e. a generic method invocation like container.Resolve()
    var token = util.getPreviousNonWsToken(context.tokens, context.index);
    if (token) if (token.name === "ident" || token.name === "keyword" && util.contains(primitives.concat(["string", "object", "void"]), token.value) || token.name === "operator" && token.value === ".") {
      return false;
    }

    // needs to be immediately followed by <, then by idents, acceptable keywords and ",", and then closed by >, then immediately followed by an ident
    token = util.getNextNonWsToken(context.tokens, context.index);
    if (!token || token.name !== "operator" || token.value !== "<") return false;

    var bracketCount = [0, 0]; // open (<), close (>)
    var walker = context.getTokenWalker();
    while (walker.hasNext()) {
      var _token2 = walker.next();
      if (_token2.name === "operator") {
        switch (_token2.value) {
          case "<":
            bracketCount[0]++;
            break;
          case "<<":
            bracketCount[0] += 2;
            break;
          case ">":
            bracketCount[1]++;
            break;
          case ">>":
            bracketCount[1] += 2;
            break;
          default:
            return false;
        }
        // if bracket counts match, get the f out
        if (bracketCount[0] === bracketCount[1]) break;

        continue;
      }

      if (_token2.name === "default" || _token2.name === "ident" || _token2.name === "keyword" && util.contains(acceptableKeywords, _token2.value) || _token2.name === "punctuation" && _token2.value === ",") continue;

      return false;
    }

    // verify bracket count, if mismatched, could be something scary
    if (bracketCount[0] !== bracketCount[1]) return false;

    // next token should be optional whitespace followed by an ident
    if (!walker.hasNext()) return false;
    token = walker.next();
    if (token.name === "default") {
      if (!walker.hasNext()) return false;
      token = walker.next();
    }
    return token.name === "ident";
  },

  // after class keyword but inside <>
  function (context) {
    var prevToken = util.getPreviousNonWsToken(context.tokens, context.index);

    if (!prevToken || prevToken.name !== "keyword" || prevToken.value !== "class") return false;

    // make sure we're not inside <>
    // easiest way is to go forward and verify that we hit a "{" before a ">"
    var walker = context.getTokenWalker();
    while (walker.hasNext()) {
      var token = walker.next();
      if (token.name === "punctuation" && token.value === "{") return true;

      if (token.name === "operator" && util.contains([">", ">>"], token.value)) return false;
    }

    return false;
  }],

  follows: [[{ token: "keyword", values: ["enum", "struct", "union"] }, util.whitespace]],

  precedes: [
  // normal parameters/declarations
  [{ token: "default" }, { token: "ident" }], [util.whitespace, { token: "operator", values: ["*", "**"] }, { token: "default" }, { token: "ident" }, util.whitespace, { token: "operator", values: ["=", ","] }], [util.whitespace, { token: "operator", values: ["*", "**"] }, { token: "default" }, { token: "operator", values: ["&"] }, util.whitespace, { token: "ident" }, util.whitespace, { token: "operator", values: ["=", ","] }],

  // e.g. "std" in "std::char_traits<CharT>"
  [util.whitespace, { token: "operator", values: ["::"] }]]
};

// http://www.cppreference.com/wiki/language/operator_precedence
var operators = exports.operators = ["==", "=", "+=", "++", "+", "->*", "->", "-=", "--", "-", "**", "*=", "*", // added ** for double pointer convenience
"/=", "/", "%=", "%", "!=", "!", ">>=", ">>", ">=", ">", "<<=", "<<", "<=", "<", "&=", "&&", "&", "|=", "||", "|", "~", "^=", "^", ".*", ".", "?", "::", ":", ","];