"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultAnalyzer = undefined;
exports.defaultNumberParser = defaultNumberParser;

var _analyzer = require("./analyzer.js");

var _rulesProcessor = require("./rules-processor.js");

/* eslint no-magic-numbers: ["error", { "ignore": [-1, 0, 1, 2] }], camelcase: 0 */

class defaultAnalyzer extends _analyzer.Analyzer {
  constructor() {
    super();
    this.handlers.default = this.handleDefault;
    this.handlers.ident = this.handleIdent;
  }

  // just append default content as a text node
  handleDefault(context) {
    context.addNode(context.createTextNode(context.tokens[context.index]));
    return true;
  }

  // this handles the named ident mayhem
  handleIdent(context) {
    var rules = context.language.namedIdentRules;
    var caseInsensitive = context.language.caseInsensitive;

    var isNamedIdent = rules.custom.some(function (rule) {
      return rule(context);
    }) || rules.precedes.some(function (rule) {
      return (0, _rulesProcessor.IsPrecedesRuleSatisfied)(context.getTokenWalker(), rule, caseInsensitive);
    }) || rules.follows.some(function (rule) {
      return (0, _rulesProcessor.IsFollowsRuleSatisfied)(context.getTokenWalker(), rule, caseInsensitive);
    }) || rules.between.some(function (rule) {
      return (0, _rulesProcessor.IsBetweenRuleSatisfied)(context.getTokenWalker(), rule.opener, rule.closer, caseInsensitive);
    });

    if (isNamedIdent) _analyzer.Analyzer.defaultHandleToken("named-ident")(context);else super.handleToken(context);

    return true;
  }
}

exports.defaultAnalyzer = defaultAnalyzer; /**
                                            * The default number parser.
                                            * @param {ParserContext} context
                                            * @returns {Token?}
                                            */

function defaultNumberParser(context) {
  var current = context.reader.peek();

  var number = void 0;
  var allowDecimal = true;
  if (!/\d/.test(current)) {
    // is it a decimal followed by a number?
    if (current !== "." || !/\d/.test(context.reader.peekWithOffset(1))) return null;

    // decimal without leading zero
    number = context.reader.read(2);
    allowDecimal = false;
  } else {
    number = context.reader.read();
    if (current === "0" && context.reader.peek() !== ".")
      // hex or octal
      allowDecimal = false;
  }

  // easy way out: read until it's not a number or letter
  // this will work for hex (0xef), octal (012), decimal and scientific notation (1e3)
  // anything else and you're on your own
  while (!context.reader.isEOF()) {
    var peek = context.reader.peek();
    if (!/[A-Za-z0-9]/.test(peek)) {
      if (peek === "." && allowDecimal && /\d$/.test(context.reader.peek(2))) {
        number += context.reader.read();
        allowDecimal = false;
        continue;
      }
      break;
    }
    number += context.reader.read();
  }
  return context.createToken("number", number);
}