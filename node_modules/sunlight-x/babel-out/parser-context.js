"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.ParserContext = undefined;
exports.Tokenize = Tokenize;

var _arrayWalker = require("./array-walker.js");

var _codeReader = require("./code-reader.js");

var _events = require("./events.js");

var _token = require("./token.js");

var _parseNextToken = require("./parse-next-token.js");

var _userDefinedNameStore = require("./user-defined-name-store.js");

var _util = require("./util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

class ParserContext {

  constructor(highlighter, unhighlightedCode, language, userDefinedNameStore, partialContext, options) {
    this.highlighter = highlighter;
    this.userDefinedNameStore = userDefinedNameStore;
    this.options = options;
    this.tokens = [];

    _events.BeforeTokenizeEvent.raise(this.highlighter, {
      code: unhighlightedCode,
      language: language
    });

    this.reader = new _codeReader.CodeReader(unhighlightedCode);
    this.language = language;
    this.items = util.clone(language.contextItems);
    this.embeddedLanguageStack = [];
    this.defaultData = { text: "", line: 1, column: 1 };

    // If a continuation is given, then we need to pick up where we left off
    // from a previous parse. That indicates that a scope was not yet closed, so
    // so we need to continue that scope.
    if (partialContext && partialContext.continuation) this.tokens.push(partialContext.continuation.process(this, // this.continuation may be overwritten.
    partialContext.continuation, ""));

    while (!this.reader.isEOF()) {
      this.highlighter.switchToEmbeddedLanguageIfNecessary(this);
      var token = (0, _parseNextToken.parseNextToken)(this);

      if (token !== null && token !== undefined) {
        // Write the stored default data if exist. These data are meant to be
        // joined into a single default token before writing.
        // Note: default data are whitespace and things marked not to parse.
        if (this.defaultData.text !== "") {
          this.tokens.push(this.createToken("default", this.defaultData.text));
          this.defaultData.text = "";
        }

        if (Array.isArray(token)) this.tokens = this.tokens.concat(token);else this.tokens.push(token);
      }

      this.highlighter.switchBackFromEmbeddedLanguageIfNecessary(this);
    }

    // append the last default token, if necessary
    if (this.defaultData.text !== "") this.tokens.push(this.createToken("default", this.defaultData.text));

    _events.AfterTokenizeEvent.raise(this.highlighter, {
      code: unhighlightedCode,
      parserContext: this
    });
  }

  token(index) {
    return this.tokens[index];
  }

  getAllTokens() {
    return this.tokens.slice(0);
  }

  count() {
    return this.tokens.length;
  }

  // Create a token walker that is positioned at the end of the tokens. Use
  // walker.prev() to receive the last token.
  getTokenWalker() {
    return new _arrayWalker.ArrayWalker(this.tokens, this.tokens.length);
  }

  createToken(name, value) {
    return new _token.Token(name, value, this.language.name);
  }
}

exports.ParserContext = ParserContext; /**
                                        * Tokenize and return a ParserContext
                                        * @param {Highlighter} highlighter
                                        * @param {string} unhighlightedCode
                                        * @param {Language} language
                                        * @param {UserDefinedNameStore} userDefinedNameStore
                                        * @param {AnalyzerContext} partialContext
                                        * @param {SunlightOptionsType} options
                                        * @returns {ParserContext}
                                        */
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

function Tokenize(highlighter, unhighlightedCode, language, userDefinedNameStore, partialContext, options) {
  return new ParserContext(highlighter, unhighlightedCode, language, userDefinedNameStore, partialContext, options);
}