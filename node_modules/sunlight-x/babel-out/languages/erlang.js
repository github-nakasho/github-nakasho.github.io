"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.scopes = exports.customTokens = exports.customParseRules = exports.keywords = exports.name = undefined;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var name = exports.name = "erlang";

// http://www.haskell.org/haskellwiki/Keywords
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var keywords = exports.keywords = ["after", "andalso", "and", "band", "begin", "bnot", "bor", "bsl", "bsr", "bxor", "case", "catch", "cond", "div", "end", "fun", "if", "let", "not", "of", "orelse", "or", "query", "receive", "rem", "try", "when", "xor", "true", "false"];

var customParseRules = exports.customParseRules = [
// atom/function/userDefinedFunction detection
function (context) {
  if (!/[A-Za-z_]/.test(context.reader.peek())) return null;

  var peek = void 0;
  // read the ident (they can have letters, numbers, underscores and @-signs in them)
  var offset = void 0;
  for (offset = 1;; offset++) {
    var _peek = context.reader.peekWithOffset(offset);
    if (_peek === "" || !/[\w@]/.test(_peek)) break;
  }

  var ident = context.reader.peek(offset);

  // if the next non-whitespace character is "(", then it's a function
  var isFunction = false;
  for (;; offset++) {
    var _peek2 = context.reader.peekWithOffset(offset);
    if (_peek2 === "") break;

    if (!/^\s$/.test(_peek2)) {
      if (_peek2 === "(") isFunction = true;
      break;
    }
  }

  // a little inefficient because reading the ident will have to happen again,
  // but it might be a keyword or something
  if (!isFunction && !/^[A-Z_]/.test(ident)) return null;

  context.reader.read(ident.length);
  offset -= ident.length;

  if (!isFunction) return context.createToken("ident", ident);

  var parenCount = 1; // Already read a "(" before.
  // is it a function declaration? (preceded by -> operator)
  for (offset++; parenCount > 0; offset++) {
    var _peek3 = context.reader.peekWithOffset(offset);
    if (_peek3 === "") break;

    if (_peek3 === "(") parenCount++;else if (_peek3 === ")") parenCount--;
  }

  // the next thing is a bunch of whitespace followed by ->, or fail
  for (;; offset++) {
    peek = context.reader.peekWithOffset(offset);
    if (peek === "" || !/^\s$/.test(peek)) break;
  }

  if (context.reader.peekWithOffset(offset, 2) === "->") {
    // function declaration
    context.userDefinedNameStore.addName(ident, name);
    return context.createToken("userDefinedFunction", ident);
  }

  // just a regular function call
  return context.createToken("function", ident);
}];

var customTokens = exports.customTokens = {
  moduleAttribute: {
    values: ["-module", "-export", "-import", "-compile", "-vsn", "-behaviour", "-record", "-include", "-define", "-file", "-type", "-spec", "on_load"],
    boundary: "\\b"
  },

  macroDirective: {
    values: ["-undef", "-ifdef", "-ifndef", "-else", "-endif"],
    boundary: "\\b"
  }
};

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false]],
  quotedAtom: [["'", "'", ["\\'", "\\\\"], false]],
  comment: [["%", "\n", [], true]],
  char: [["$", { regex: /[^\w\\]/, length: 1 }, [], true]],
  macro: [["?", { regex: /[^\w?]/, length: 1 }, [], true]]
};

var identFirstLetter = exports.identFirstLetter = /[A-Za-z_]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /[\w@]/;

var namedIdentRules = exports.namedIdentRules = {
  custom: [function (context) {
    return context.userDefinedNameStore.hasName(context.tokens[context.index].value, name);
  }],

  precedes: [[{ token: "operator", values: [":"] }]]
};

var operators = exports.operators = ["<-", "<", "||", "=:=", "=/=", "==", "=<", "=", "*", "<<", ",", ">=", ">>", ">", ":", "#", "!", "++", "+", "->", "--", "-", "/=", "/"];