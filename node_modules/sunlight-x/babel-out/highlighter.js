"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Highlighter = undefined;

var _util = require("./util.js");

var util = _interopRequireWildcard(_util);

var _constants = require("./constants.js");

var _globalOptions = require("./globalOptions.js");

var _events = require("./events.js");

var _languages = require("./languages.js");

var _analyzerContext = require("./analyzer-context.js");

var _parserContext = require("./parser-context.js");

var _logger = require("./logger.js");

var _userDefinedNameStore = require("./user-defined-name-store.js");

var _jsdom = require("./jsdom.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

// TODO: Redo count. Is there really a need to increase count for sub-nodes?
// sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var HIGHLIGHTED_NODE_COUNT = 0;

/**
 * Append all children to the parent node.
 * @param {Node} parent
 * @param {Node[]} children
 */
function appendAll(parent, children) {
  for (var i = 0; i < children.length; i++) {
    parent.appendChild(children[i]);
  }
}

class Highlighter {

  constructor(options) {
    this.options = Object.assign({}, _globalOptions.globalOptions, options);
  }

  // called before processing the current
  switchToEmbeddedLanguageIfNecessary(context) {
    for (var i = 0; i < context.language.embeddedLanguages.length; i++) {
      if (!_languages.languages[context.language.embeddedLanguages[i].language])
        // unregistered language
        continue;

      var embeddedLanguage = util.clone(context.language.embeddedLanguages[i]);

      if (embeddedLanguage.switchTo(context)) {
        embeddedLanguage.oldItems = util.clone(context.items);
        context.embeddedLanguageStack.push(embeddedLanguage);
        context.language = _languages.languages[embeddedLanguage.language];
        context.items = Object.assign(context.items, util.clone(context.language.contextItems));
        break;
      }
    }
  }

  // called after processing the current
  switchBackFromEmbeddedLanguageIfNecessary(context) {
    var current = util.lastElement(context.embeddedLanguageStack);

    if (current && current.switchBack(context)) {
      context.language = _languages.languages[current.parentLanguage];
      var lang = context.embeddedLanguageStack.pop();

      // restore old items
      context.items = util.clone(lang.oldItems);
      lang.oldItems = {};
    }
  }

  createContainer(context) {
    var container = _jsdom.document.createElement("span");
    container.className = (context.options.classPrefix || "") + context.language.name;
    return container;
  }

  analyze(analyzerContext, startIndex) {
    var _this = this;

    _events.BeforeAnalyzeEvent.raise(this, { analyzerContext: analyzerContext });

    if (analyzerContext.tokens.length > 0) {
      analyzerContext.language = _languages.languages[analyzerContext.tokens[0].language] || _languages.languages[_constants.DEFAULT_LANGUAGE];
      var nodes = [];
      var container = this.createContainer(analyzerContext);

      var _loop = function _loop(i) {
        var language = _languages.languages[analyzerContext.tokens[i].language] || _languages.languages[_constants.DEFAULT_LANGUAGE];
        if (language.name !== analyzerContext.language.name) {
          appendAll(container, analyzerContext.getNodes());
          analyzerContext.resetNodes();

          nodes.push(container);
          analyzerContext.language = language;
          container = _this.createContainer(analyzerContext);
        }

        analyzerContext.index = i;
        var tokenName = analyzerContext.tokens[i].name;
        if (![...analyzerContext.analyzerOverrides, analyzerContext.language.analyzer].some(function (analyzer) {
          if (analyzer.handlers.hasOwnProperty(tokenName)) {
            analyzer.handlers[tokenName](analyzerContext);
            return true;
          }
          return false;
        })) analyzerContext.language.analyzer.handleToken(analyzerContext);
      };

      for (var i = startIndex; i < analyzerContext.tokens.length; i++) {
        _loop(i);
      }

      // append the last nodes, and add the final nodes to the context
      appendAll(container, analyzerContext.getNodes());
      nodes.push(container);
      analyzerContext.resetNodes();
      for (var i = 0; i < nodes.length; i++) {
        analyzerContext.addNode(nodes[i]);
      }
    }

    _events.AfterAnalyzeEvent.raise(this, { analyzerContext: analyzerContext });
  }

  // partialContext allows us to perform a partial parse, and then pick up where
  // we left off at a later time this functionality enables nested highlights
  // (language within a language, e.g. PHP within HTML followed by more PHP)
  _highlightText(unhighlightedCode, languageId, userDefinedNameStore, partialContext) {
    var language = _languages.languages[languageId];

    if (language === undefined)
      // use default language if one wasn't specified or hasn't been registered
      language = _languages.languages[_constants.DEFAULT_LANGUAGE];

    _events.BeforeHighlightEvent.raise(this, {
      code: unhighlightedCode,
      language: language,
      previousContext: partialContext
    });

    var analyzerContext = new _analyzerContext.AnalyzerContext((0, _parserContext.Tokenize)(this, unhighlightedCode, language, userDefinedNameStore, partialContext, this.options), userDefinedNameStore, partialContext, this.options);

    this.analyze(analyzerContext, partialContext && partialContext.index ? partialContext.index + 1 : 0);

    _events.AfterHighlightEvent.raise(this, { analyzerContext: analyzerContext });

    return analyzerContext;
  }

  getAllHighlightableNodes() {
    var classPrefix = this.options.classPrefix + "highlight-";
    return _jsdom.document.querySelectorAll(`[class^="${classPrefix}"]`);
  }

  getLanguageFromNode(node) {
    var classPrefix = this.options.classPrefix + "highlight-";
    var classList = node.className.split(" ");
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = classList[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var classItem = _step.value;

        if (classItem.startsWith(classPrefix)) return classItem.substring(classPrefix.length);
      } // FIXME: Code goes to here when switching languages.
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return undefined;
  }

  // determines if the node has already been highlighted
  isAlreadyHighlighted(node) {
    return node.classList.contains(this.options.classPrefix + "highlighted");
  }

  // Highlights a block of text. DEPRECATED.
  highlight(code, languageId) {
    return this._highlightText(code, languageId, new _userDefinedNameStore.UserDefinedNameStore(), undefined);
  }

  /**
   * Recursively highlights a DOM node. The node should have the class of
   * "sunlight-highlight-[lang]", or "[prefix]highlight-[lang]" if you have a
   * custom prefix.
   * @param {Element} node The element to be highlighted.
   * @param {boolean?} addContainer Whether to add the container. If omitted,
   * container will be added if it is a block element. (TODO: should we make it
   * omit == true?)
   */
  highlightNode(node, addContainer) {
    if (this.isAlreadyHighlighted(node)) return;

    var languageId = this.getLanguageFromNode(node);
    if (!languageId) return;

    _events.BeforeHighlightNodeEvent.raise(this, { node: node });

    var currentNodeCount = 0;
    var userDefinedNameStore = new _userDefinedNameStore.UserDefinedNameStore();
    var partialContext = undefined;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = node.childNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var childNode = _step2.value;

        if (childNode.nodeType === _constants.TEXT_NODE) {
          // text nodes
          partialContext = this._highlightText(childNode.nodeValue, languageId, userDefinedNameStore, partialContext);
          HIGHLIGHTED_NODE_COUNT++;
          currentNodeCount = currentNodeCount || HIGHLIGHTED_NODE_COUNT;

          var nodes = partialContext.getNodes();
          if (!nodes[0]) nodes[0] = _jsdom.document.createTextNode("");
          node.replaceChild(nodes[0], childNode);
          for (var k = 1; k < nodes.length; k++) {
            node.insertBefore(nodes[k], nodes[k - 1].nextSibling);
          }
        } else if (childNode instanceof _jsdom.window.Element) {
          // element nodes
          this.highlightNode(childNode);
        }
      } // indicate that this node has been highlighted
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    node.className += " " + this.options.classPrefix + "highlighted";

    // If the node is block level, or if we cannot know the style, put the code
    // inside a container.
    var style = util.getComputedStyle(node, "display");
    if (addContainer === true || addContainer !== false && (!style || style === "block")) {
      var container = _jsdom.document.createElement("div");
      container.className = this.options.classPrefix + "container";

      if (this.options.theme) container.classList.add(`${this.options.classPrefix}theme-${this.options.theme}`);

      var codeContainer = _jsdom.document.createElement("div");
      codeContainer.className = this.options.classPrefix + "code-container";

      // apply max height if specified in options
      if (this.options.maxHeight !== false) {
        codeContainer.style.overflowY = "auto";
        codeContainer.style.maxHeight = this.options.maxHeight + (/^\d+$/.test(this.options.maxHeight) ? "px" : "");
      }

      container.appendChild(codeContainer);

      var parentNode = node.parentNode;
      if (parentNode) {
        parentNode.insertBefore(container, node);
        codeContainer.appendChild(parentNode.removeChild(node));
      } else {
        (0, _logger.errorInvalidValue)("highlightNode: node has no parent node.");
      }

      _events.AfterHighlightNodeEvent.raise(this, {
        container: container,
        codeContainer: codeContainer,
        node: node,
        count: currentNodeCount
      });
    } else {
      _events.AfterHighlightNodeEvent.raise(this, {
        node: node,
        count: currentNodeCount
      });
    }
  }

  /**
   * Highlights the given code and returns the HTML Element.
   * @param {string} code
   * @param {string} languageId
   * @returns {Element}
   */
  highlightCodeAsElement(code, languageId) {
    var preElement = _jsdom.document.createElement("pre");
    // Note: setting innerText does not work in jsdom 9.4.2
    preElement.appendChild(_jsdom.document.createTextNode(code));
    preElement.setAttribute("class", this.options.classPrefix + "highlight-" + languageId);

    var codeElement = _jsdom.document.createElement("div");
    codeElement.appendChild(preElement);

    this.highlightNode(preElement, true);

    var ret = codeElement.childNodes[0];
    if (!(ret instanceof _jsdom.window.Element)) {
      (0, _logger.error)("Internal error.");
      return codeElement;
    }
    return ret;
  }

  /**
   * Highlights the given code and returns the HTML as a string.
   * @param {string} code
   * @param {string} languageId
   * @returns {Element}
   */
  highlightCode(code, languageId) {
    return this.highlightCodeAsElement(code, languageId).outerHTML;
  }

  // Reset HIGHLIGHTED_NODE_COUNT to zero. Run this before a layout test.
  static resetNodeCount() {
    HIGHLIGHTED_NODE_COUNT = 0;
  }
}
exports.Highlighter = Highlighter;