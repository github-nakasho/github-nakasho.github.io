"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.operators = exports.namedIdentRules = exports.identAfterFirstLetter = exports.identFirstLetter = exports.customParseRules = exports.scopes = exports.customTokens = exports.keywords = exports.name = undefined;

var _util = require("../util.js");

var util = _interopRequireWildcard(_util);

var _regexp = require("./common/regexp.js");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* eslint no-magic-numbers: 1 */
var name = exports.name = "actionscript"; // sunlight-x: Intelligent Syntax Highlighting, Modernized
// Copyright 2017 Leung Wing-chung. All rights reserved.
// Use of this source code is governed by a Apache License Version 2.0, that can
// be found in the LICENSE file.

var keywords = exports.keywords = ["default xml namespace", "use namespace", "break", "case", "catch", "continue", "default", "do", "else", "finally", "for", "if", "in", "label", "return", "super", "switch", "throw", "try", "while", "with", "dynamic", "final", "internal", "native", "override", "private", "protected", "public", "static", "class", "const", "extends", "function", "get", "implements", "interface", "namespace", "package", "set", "var", "import", "include", "false", "null", "this", "true", "typeof", "void", "as", "instanceof", "is", "new"];

var customTokens = exports.customTokens = {
  varArgs: {
    values: ["...rest"],
    boundary: "[\\W]"
  },

  constant: {
    values: ["Infinity", "NaN", "undefined"],
    boundary: "\\b"
  },

  globalObject: {
    values: ["ArgumentError", "arguments", "Array", "Boolean", "Class", "Date", "DefinitionError", "Error", "EvalError", "Function", "int", "Math", "Namespace", "Number", "Object", "QName", "RangeError", "ReferenceError", "RegExp", "SecurityError", "String", "SyntaxError", "TypeError", "uint", "URIError", "Vector", "VerifyError", "XMLList", "XML"],
    boundary: "\\b"
  }
};

var scopes = exports.scopes = {
  string: [['"', '"', util.escapeSequences.concat(['\\"']), false], ["'", "'", util.escapeSequences.concat(["\\'", "\\\\"]), false]],
  comment: [["//", "\n", [], true], ["/*", "*/", [], false]],
  xmlAttribute: [["@", "\\b", [], false]]
};

var customParseRules = exports.customParseRules = [
// global functions: //http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/package-detail.html
function () {
  var functions = util.createHashMap(["Array", "Boolean", "decodeURIComponent", "decodeURI", "encodeURIComponent", "encodeURI", "escape", "int", "isFinite", "isNaN", "isXMLName", "Number", "Object", "parseFloat", "parseInt", "String", "trace", "uint", "unescape", "Vector", "XML", "XMLList"], "\\b", false);

  return function (context) {
    // short circuit
    if (!/[A-Za-z]/.test(context.reader.peek())) return null;

    // if it follows "new" or ":", then it's not a function
    var walker = context.getTokenWalker();
    if (walker.hasPrev()) {
      var prevToken = walker.prev();
      if (prevToken.name === "keyword" && prevToken.value === "new" || prevToken.name === "operator" && prevToken.value === ":") return null;
    }

    var token = util.matchWord(context, functions, "globalFunction", true);
    if (!token) return null;

    // Grab the next non-whitespace character, and make sure it is a "(".
    for (var offset = token.value.length;; offset++) {
      var peek = context.reader.peekWithOffset(offset);
      if (peek === "(") break;
      if (peek === "" || !/^\s$/.test(peek)) return null;
    }

    context.reader.read(token.value.length);
    return new _util.Token(token.name, token.value, token.language);
  };
}(),

// regex literal, stolen from javascript
_regexp.ParseRegExpLiteral];

var identFirstLetter = exports.identFirstLetter = /[A-Za-z_]/;
var identAfterFirstLetter = exports.identAfterFirstLetter = /\w/;

var namedIdentRules = exports.namedIdentRules = {
  custom: [function (context) {
    // next token is not "."
    var nextToken = util.getNextNonWsToken(context.tokens, context.index);
    if (nextToken && nextToken.name === "operator" && nextToken.value === ".") return false;

    // go backward and make sure that there are only idents and dots before the new keyword
    var previous = null;
    var walker = context.getTokenWalker();
    while (walker.hasPrev()) {
      var token = walker.prev();

      if (token.name === "keyword" && util.contains(["new", "is", "instanceof", "import"], token.value)) return true;

      if (token.name === "default") continue;

      if (token.name === "ident") {
        if (previous && previous.name === "ident") return false;

        previous = token;
        continue;
      }

      if (token.name === "operator" && token.value === ".") {
        if (previous && previous.name !== "ident") return false;

        previous = token;
        continue;
      }

      break;
    }

    return false;
  }],

  follows: [[{ token: "keyword", values: ["class", "extends"] }, { token: "default" }], [{ token: "operator", values: [":"] }, util.whitespace]],

  between: [{
    opener: { token: "keyword", values: ["implements"] },
    closer: { token: "punctuation", values: ["{"] }
  }]
};

var operators = exports.operators = [
// arithmetic
"++", "+=", "+", "--", "-=", "-", "*=", "*", "/=", "/", "%=", "%",

// boolean
"&&=", "&&", "||=", "||",

// bitwise
"|=", "|", "&=", "&", "^=", "^", ">>>=", ">>>", ">>=", ">>", "<<=", "<<",

// inequality
"<=", "<", ">=", ">", "===", "==", "!==", "!=",

// unary
"!", "~",

// other
"::", "?", ":", ".", "="];